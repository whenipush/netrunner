package handlers

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"netrunner/models"
	"netrunner/parser"
	"os"
	"strings"
)

type PentestReportController struct {
	Task     models.TaskStatus
	report   PentestReport
	NmapData NmapRun
}

type PentestReport struct {
	Info  GeneralInfo            `json:"general_info"`
	Hosts map[string]PentestHost `json:"hosts"`
	Diff  map[string]PentestDiff `json:"diff"`
}

type GeneralInfo struct {
	TaskName    string `json:"task_name"`
	StartTime   string `json:"start"`
	EndTime     string `json:"end"`
	Version     string `json:"version"`
	TimeElapsed string `json:"elapsed"`
	Summary     string `json:"summary"`
	UpHosts     int    `json:"up"`
	DownHosts   int    `json:"down"`
	TotalHosts  int    `json:"total"`
}

type PentestHost struct {
	Ip     string                  `json:"ip"`
	Ports  []PentestPort           `json:"ports"`
	Status string                  `json:"status"`
	Vulns  map[string]PentestVulns `json:"vulns"`
}
type PentestPort struct {
	Port     int    `json:"port"`
	Protocol string `json:"protocol"`
	Service  string `json:"service"`
	State    string `json:"state"`
}
type PentestVulns struct {
	CPE         string           `json:"cpe"`
	CVSS        string           `json:"cvss"`
	CVSSVector  string           `json:"cvss_vector"`
	CWE         []string         `json:"cwe"`
	Description string           `json:"description"`
	Id          string           `json:"id"`
	Port        int              `json:"port"`
	References  string           `json:"references"`
	Solutions   []parser.Details `json:"solutions"`
}
type PentestDiff struct {
	Added   map[string]PentestVulns `json:"+"`
	Removed map[string]PentestVulns `json:"-,"`
}

// ProcessNmapFile reads XML, parses and saves as JSON.
func (p *PentestReportController) ProcessPentest(task models.TaskStatus) (string, error) {
	p.Task = task
	report := fmt.Sprintf("report/pentest/%s.xml", p.Task.NumberTask)
	inputFile := report
	outputFile := report + ".json"
	data, err := os.ReadFile(inputFile)
	if err != nil {
		return "", err
	}

	p.NmapData, err = Parse(data)
	if err != nil {
		return "", err
	}

	p.generateJSON()
	err = p.saveJSONToFile()
	if err != nil {
		return "", err
	}
	log.Printf("%v", p.report)
	return outputFile, err
}

// saveJSONToFile saves JSON to a file.
func (p *PentestReportController) saveJSONToFile() error {
	report := fmt.Sprintf("report/pentest/%s.xml", p.Task.NumberTask) + ".json"
	file, err := os.Create(report)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(p.report)
}

// generateJSON generates JSON structure.
func (p *PentestReportController) generateJSON() {
	hosts := p.extractHostsInfo()
	p.report = PentestReport{
		Info: GeneralInfo{
			TaskName:    p.Task.Name,
			StartTime:   p.NmapData.StartStr,
			EndTime:     p.NmapData.RunStats.Finished.TimeStr,
			Version:     p.NmapData.Version,
			TimeElapsed: fmt.Sprintf("%.2f", p.NmapData.RunStats.Finished.Elapsed),
			Summary:     p.NmapData.RunStats.Finished.Summary,
			UpHosts:     p.NmapData.RunStats.Hosts.Up,
			DownHosts:   p.NmapData.RunStats.Hosts.Down,
			TotalHosts:  p.NmapData.RunStats.Hosts.Total,
		},
		Hosts: hosts,
	}
	p.report.Diff = p.diffReport()
	// 	p.report = map[string]interface{}{
	// 	"general_info": map[string]interface{}{
	// 		"task_name": p.Task.Name,
	// 		"start":     p.NmapData.StartStr,
	// 		"end":       p.NmapData.RunStats.Finished.TimeStr,
	// 		"version":   p.NmapData.Version,
	// 		"elapsed":   fmt.Sprintf("%.2f", p.NmapData.RunStats.Finished.Elapsed),
	// 		"summary":   p.NmapData.RunStats.Finished.Summary,
	// 		"up":        p.NmapData.RunStats.Hosts.Up,
	// 		"down":      p.NmapData.RunStats.Hosts.Down,
	// 		"total":     p.NmapData.RunStats.Hosts.Total,
	// 	},
	// 	"hosts": hosts,
	// 	"diff":  p.diffReport(),
	// }
}

// extractHostsInfo extracts host information.
func (p *PentestReportController) extractHostsInfo() map[string]PentestHost {
	var hostList map[string]PentestHost = make(map[string]PentestHost)
	hosts := p.NmapData.Hosts
	for _, host := range hosts {
		hostInfo := PentestHost{
			Ip:     getAddress(host.Addresses),
			Status: host.Status.State,
			Ports:  extractPortsInfo(host.Ports),
			Vulns:  extractHostVulns(host),
			//"scripts":      extractHostScripts(host.HostScripts), // Adding scripts for ports
			//"host_scripts": extractHostScripts(host.HostScripts), // Adding host scripts
		}
		hostList[getAddress(host.Addresses)] = hostInfo
		//hostList = append(hostList, hostInfo)
	}
	return hostList
}

func extractHostVulns(host Host) map[string]PentestVulns {
	var vulnsList map[string]PentestVulns = make(map[string]PentestVulns)
	//var vulnArray []parser.Vulnerability
	for _, port := range host.Ports {

		for _, script := range port.Scripts {
			if script.Id == "vulners" {
				scanner := bufio.NewScanner(strings.NewReader(script.Output))
				for scanner.Scan() {
					fields := strings.Fields(scanner.Text())
					if len(fields) == 0 {
						continue
					}
					if strings.Contains(fields[0], "CVE") {
						cve := parser.Database[fields[0]]
						hash := Hash(fields[0]) * uint64(port.PortId) * Hash(script.Tables[0].Key)
						vulnsList[fmt.Sprintf("%0.16x", hash)] = PentestVulns{
							Id:          fields[0],
							CVSS:        fields[1],
							CVSSVector:  cve.Cvss.Vector,
							CWE:         cve.CWE,
							References:  cve.Link,
							Port:        port.PortId,
							CPE:         script.Tables[0].Key,
							Description: cve.Descrption,
							Solutions:   cve.Solutions,
						}
						/*
							vulnsList = append(vulnsList, map[string]interface{}{
								"id":          fields[0],
								"cvss":        fields[1],
								"cvss_vector": cve.Cvss.Vector,
								"cwe":         cve.CWE,
								"references":  cve.Link,
								//"references":  fields[2],
								"port":        port.PortId,
								"cpe":         script.Tables[0].Key,
								"description": cve.Descrption,
								"solutions":   cve.Solutions,
							})*/
					}
				}
			}
		}
	}
	log.Printf("Nmap output : %d", len(vulnsList))
	return vulnsList
}

func extractHostScripts(scripts []Script) []map[string]interface{} {
	var scriptList []map[string]interface{}
	for _, script := range scripts {
		scriptList = append(scriptList, map[string]interface{}{
			"id":     script.Id,
			"output": interpretScriptOutput(script.Output),
		})
	}
	return scriptList
}

// extractPortsInfo extracts port information.
func extractPortsInfo(ports []Port) []PentestPort {
	var portList []PentestPort
	for _, port := range ports {
		portList = append(portList, PentestPort{
			Port:     port.PortId,
			Protocol: port.Protocol,
			State:    port.State.State,
			Service:  port.Service.Name,
			//"scripts":  extractHostScripts(port.Scripts),
		})
	}
	return portList
}

// getAddress gets IP address from addresses.
func getAddress(addresses []Address) string {
	for _, addr := range addresses {
		if addr.AddrType == "ipv4" || addr.AddrType == "ipv6" {
			return addr.Addr
		}
	}
	return "unknown"
}

func interpretScriptOutput(output string) string {
	output = strings.ToLower(output)

	switch {
	case strings.Contains(output, "vulnerable"):
		return "Уязвимость обнаружена"
	case strings.Contains(output, "exploitable"):
		return "Уязвимость может быть использована"
	case strings.Contains(output, "vulnerability detected"):
		return "Уязвимость подтверждена"
	case strings.Contains(output, "not vulnerable"):
		return "Уязвимость отсутствует"
	case strings.Contains(output, "false"):
		return "Уязвимость не найдена"
	case strings.Contains(output, "no issues found"):
		return "Проблем не обнаружено"
	case strings.Contains(output, "secure"):
		return "Конфигурация безопасна"
	case strings.Contains(output, "access denied"):
		return "Доступ запрещен"
	case strings.Contains(output, "nt_status_access_denied"):
		return "Ошибка доступа (Windows)"
	case strings.Contains(output, "permission denied"):
		return "Отказано в разрешении"
	case strings.Contains(output, "authentication required"):
		return "Требуется аутентификация"
	/*case strings.Contains(output, "error"):
	return "Общая ошибка"*/
	case strings.Contains(output, "failed"):
		return "Тест не выполнен"
	case strings.Contains(output, "could not connect"):
		return "Не удалось подключиться"
	case strings.Contains(output, "timeout"):
		return "Превышено время ожидания"
	case strings.Contains(output, "connection refused"):
		return "Соединение отклонено"
	case strings.Contains(output, "host unreachable"):
		return "Хост недоступен"
	case strings.Contains(output, "info"):
		return "Общая информация"
	case strings.Contains(output, "discovered"):
		return "Выявлены определенные параметры"
	case strings.Contains(output, "found"):
		return "Обнаружено"
	case strings.Contains(output, "detected"):
		return "Зафиксировано"
	case strings.Contains(output, "potentially vulnerable"):
		return "Возможно уязвим"
	case strings.Contains(output, "requires manual verification"):
		return "Требуется ручная проверка"
	case strings.Contains(output, "open to attacks"):
		return "Открыт для атак"
	case strings.Contains(output, "vulnerable but requires authentication"):
		return "Уязвимость есть, но требуется аутентификация"
	case strings.Contains(output, "incomplete test"):
		return "Тест не завершен, результат может быть неточным"
	default:
		return "Результат: " + output
	}
}
