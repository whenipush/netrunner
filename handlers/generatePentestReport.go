package handlers

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"netrunner/models"
	"netrunner/parser"
	"os"
	"strconv"
	"strings"
)

// ProcessNmapFile reads XML, parses and saves as JSON.
func ProcessPentest(task models.TaskStatus) (string, error) {
	report := fmt.Sprintf("report/pentest/%s.xml", task.NumberTask)
	inputFile := report
	outputFile := report + ".json"
	data, err := os.ReadFile(inputFile)
	if err != nil {
		return "", err
	}

	nmapData, err := Parse(data)
	if err != nil {
		return "", err
	}

	jsonData := generateJSON(nmapData)
	jsonData["general_info"].(map[string]interface{})["task_name"] = task.Name
	err = saveJSONToFile(outputFile, jsonData)
	if err != nil {
		return "", err
	}

	return outputFile, err
}

// saveJSONToFile saves JSON to a file.
func saveJSONToFile(filename string, data interface{}) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// generateJSON generates JSON structure.
func generateJSON(nmapData *NmapRun) map[string]interface{} {
	return map[string]interface{}{
		"general_info": map[string]interface{}{
			"start":   nmapData.StartStr,
			"end":     nmapData.RunStats.Finished.TimeStr,
			"version": nmapData.Version,
			"elapsed": fmt.Sprintf("%.2f", nmapData.RunStats.Finished.Elapsed),
			"summary": nmapData.RunStats.Finished.Summary,
			"up":      nmapData.RunStats.Hosts.Up,
			"down":    nmapData.RunStats.Hosts.Down,
			"total":   nmapData.RunStats.Hosts.Total,
		},
		"hosts": extractHostsInfo(nmapData.Hosts),
	}
}

// extractHostsInfo extracts host information.
func extractHostsInfo(hosts []Host) []map[string]interface{} {
	var hostList []map[string]interface{}
	for _, host := range hosts {
		hostInfo := map[string]interface{}{
			"ip":     getAddress(host.Addresses),
			"status": host.Status.State,
			"ports":  extractPortsInfo(host.Ports),
			"vulns":  extractHostVulns(host),
			//"scripts":      extractHostScripts(host.HostScripts), // Adding scripts for ports
			//"host_scripts": extractHostScripts(host.HostScripts), // Adding host scripts
		}
		hostList = append(hostList, hostInfo)
	}
	return hostList
}

func extractHostVulns(host Host) []map[string]interface{} {
	var vulnsList []map[string]interface{}
	var vulnArray = make(map[string]map[string]bool)
	//var vulnArray []parser.Vulnerability
	for _, port := range host.Ports {
		vulnArray[strconv.Itoa(port.PortId)] = make(map[string]bool)
		for _, cpe := range port.Service.CPEs {
			cpe, err := parser.NewCpe(cpe)
			if err != nil {
				log.Printf("Failed to parse cpe: %v", err)
				continue
			}
			for _, cve := range parser.Database.FindCve(*cpe) {
				vulnArray[strconv.Itoa(port.PortId)][cve.Id] = true
			}
			//vulnArray = append(vulnArray, parser.Database.FindCve(*cpe)...)
		}
		for _, script := range port.Scripts {
			if script.Id == "vulners" {
				scanner := bufio.NewScanner(strings.NewReader(script.Output))
				for scanner.Scan() {
					fields := strings.Fields(scanner.Text())
					if len(fields) == 0 {
						continue
					}
					if strings.Contains(fields[0], "CVE") {
						cve := parser.Database[fields[0]]
						vulnsList = append(vulnsList, map[string]interface{}{
							"id":          fields[0],
							"cvss":        fields[1],
							"cvss_vector": cve.Cvss.Vector,
							"references":  fields[2],
							"port":        port.PortId,
							"cpe":         script.Tables[0].Key,
							"description": cve.Descrption,
						})
					}
				}
			}
		}
	}
	var parsedI = 0
	for _, port := range vulnArray {
		for _, vul := range port {
			if vul {
				parsedI += 1
			}
		}
	}
	log.Printf("Parsed cpe database: %d", parsedI)
	log.Printf("%v", vulnArray)
	log.Printf("Nmap output : %d", len(vulnsList))
	return vulnsList
}

func extractHostScripts(scripts []Script) []map[string]interface{} {
	var scriptList []map[string]interface{}
	for _, script := range scripts {
		scriptList = append(scriptList, map[string]interface{}{
			"id":     script.Id,
			"output": interpretScriptOutput(script.Output),
		})
	}
	return scriptList
}

// extractPortsInfo extracts port information.
func extractPortsInfo(ports []Port) []map[string]interface{} {
	var portList []map[string]interface{}
	for _, port := range ports {
		portList = append(portList, map[string]interface{}{
			"port":     port.PortId,
			"protocol": port.Protocol,
			"state":    port.State.State,
			"service":  port.Service.Name,
			//"scripts":  extractHostScripts(port.Scripts),
		})
	}
	return portList
}

// getAddress gets IP address from addresses.
func getAddress(addresses []Address) string {
	for _, addr := range addresses {
		if addr.AddrType == "ipv4" || addr.AddrType == "ipv6" {
			return addr.Addr
		}
	}
	return "unknown"
}

func interpretScriptOutput(output string) string {
	output = strings.ToLower(output)

	switch {
	case strings.Contains(output, "vulnerable"):
		return "Уязвимость обнаружена"
	case strings.Contains(output, "exploitable"):
		return "Уязвимость может быть использована"
	case strings.Contains(output, "vulnerability detected"):
		return "Уязвимость подтверждена"
	case strings.Contains(output, "not vulnerable"):
		return "Уязвимость отсутствует"
	case strings.Contains(output, "false"):
		return "Уязвимость не найдена"
	case strings.Contains(output, "no issues found"):
		return "Проблем не обнаружено"
	case strings.Contains(output, "secure"):
		return "Конфигурация безопасна"
	case strings.Contains(output, "access denied"):
		return "Доступ запрещен"
	case strings.Contains(output, "nt_status_access_denied"):
		return "Ошибка доступа (Windows)"
	case strings.Contains(output, "permission denied"):
		return "Отказано в разрешении"
	case strings.Contains(output, "authentication required"):
		return "Требуется аутентификация"
	/*case strings.Contains(output, "error"):
	return "Общая ошибка"*/
	case strings.Contains(output, "failed"):
		return "Тест не выполнен"
	case strings.Contains(output, "could not connect"):
		return "Не удалось подключиться"
	case strings.Contains(output, "timeout"):
		return "Превышено время ожидания"
	case strings.Contains(output, "connection refused"):
		return "Соединение отклонено"
	case strings.Contains(output, "host unreachable"):
		return "Хост недоступен"
	case strings.Contains(output, "info"):
		return "Общая информация"
	case strings.Contains(output, "discovered"):
		return "Выявлены определенные параметры"
	case strings.Contains(output, "found"):
		return "Обнаружено"
	case strings.Contains(output, "detected"):
		return "Зафиксировано"
	case strings.Contains(output, "potentially vulnerable"):
		return "Возможно уязвим"
	case strings.Contains(output, "requires manual verification"):
		return "Требуется ручная проверка"
	case strings.Contains(output, "open to attacks"):
		return "Открыт для атак"
	case strings.Contains(output, "vulnerable but requires authentication"):
		return "Уязвимость есть, но требуется аутентификация"
	case strings.Contains(output, "incomplete test"):
		return "Тест не завершен, результат может быть неточным"
	default:
		return "Результат: " + output
	}
}
