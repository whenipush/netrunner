package handlers

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"netrunner/database"
	"netrunner/models"
	"os"
	"slices"
	"strings"
)

type PentestReportController struct {
	Task     models.TaskStatus
	report   PentestReport
	NmapData NmapRun
}

type PentestReport struct {
	Info  GeneralInfo            `json:"general_info"`
	Hosts map[string]PentestHost `json:"hosts"`
	Diff  map[string]PentestDiff `json:"diff"`
}

type GeneralInfo struct {
	TaskName    string `json:"task_name"`
	StartTime   string `json:"start"`
	EndTime     string `json:"end"`
	Version     string `json:"version"`
	TimeElapsed string `json:"elapsed"`
	Summary     string `json:"summary"`
	UpHosts     int    `json:"up"`
	DownHosts   int    `json:"down"`
	TotalHosts  int    `json:"total"`
}

type PentestHost struct {
	Ip     string                  `json:"ip"`
	Ports  []PentestPort           `json:"ports"`
	Status string                  `json:"status"`
	Vulns  map[string]PentestVulns `json:"vulns"`
}
type PentestPort struct {
	Port     int    `json:"port"`
	Protocol string `json:"protocol"`
	Service  string `json:"service"`
	State    string `json:"state"`
}
type PentestVulns struct {
	CPE         string   `json:"cpe"`
	CVSS        string   `json:"cvss"`
	CVSSVector  string   `json:"cvss_vector"`
	CWE         []string `json:"cwe"`
	Description string   `json:"description"`
	Id          string   `json:"id"`
	Port        int      `json:"port"`
	References  string   `json:"references"`
	Solutions   string   `json:"solutions"`
}
type PentestDiff struct {
	Added   map[string]PentestVulns `json:"added"`
	Removed map[string]PentestVulns `json:"removed"`
}

// ProcessNmapFile reads XML, parses and saves as JSON.
func (p *PentestReportController) ProcessPentest(task models.TaskStatus) (string, error) {
	p.Task = task
	report := fmt.Sprintf("report/pentest/%s.xml", p.Task.NumberTask)
	inputFile := report
	outputFile := report + ".json"
	data, err := os.ReadFile(inputFile)
	if err != nil {
		return "", err
	}

	p.NmapData, err = Parse(data)
	if err != nil {
		return "", err
	}

	p.generateJSON()
	err = p.saveJSONToFile()
	if err != nil {
		return "", err
	}
	return outputFile, err
}

// saveJSONToFile saves JSON to a file.
func (p *PentestReportController) saveJSONToFile() error {
	report := fmt.Sprintf("report/pentest/%s.xml", p.Task.NumberTask) + ".json"
	file, err := os.Create(report)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(p.report)
}

// generateJSON generates JSON structure.
func (p *PentestReportController) generateJSON() {
	hosts := p.extractHostsInfo()
	p.report = PentestReport{
		Info: GeneralInfo{
			TaskName:    p.Task.Name,
			StartTime:   p.NmapData.StartStr,
			EndTime:     p.NmapData.RunStats.Finished.TimeStr,
			Version:     p.NmapData.Version,
			TimeElapsed: fmt.Sprintf("%.2f", p.NmapData.RunStats.Finished.Elapsed),
			Summary:     p.NmapData.RunStats.Finished.Summary,
			UpHosts:     p.NmapData.RunStats.Hosts.Up,
			DownHosts:   p.NmapData.RunStats.Hosts.Down,
			TotalHosts:  p.NmapData.RunStats.Hosts.Total,
		},
		Hosts: hosts,
	}
	p.report.Diff = p.diffReport()
}

// extractHostsInfo extracts host information.
func (p *PentestReportController) extractHostsInfo() map[string]PentestHost {
	var hostList map[string]PentestHost = make(map[string]PentestHost)
	hosts := p.NmapData.Hosts
	for _, host := range hosts {
		hostInfo := PentestHost{
			Ip:     getAddress(host.Addresses),
			Status: host.Status.State,
			Ports:  extractPortsInfo(host.Ports),
			Vulns:  extractHostVulns(host),
			//"scripts":      extractHostScripts(host.HostScripts), // Adding scripts for ports
			//"host_scripts": extractHostScripts(host.HostScripts), // Adding host scripts
		}
		hostList[getAddress(host.Addresses)] = hostInfo
	}
	return hostList
}

func extractHostVulns(host Host) map[string]PentestVulns {
	var vulnsList map[string]PentestVulns = make(map[string]PentestVulns)
	var cves []string = make([]string, 0)
	lang := "en"
	for _, port := range host.Ports {
		for _, script := range port.Scripts {
			if script.Id == "vulners" {
				scanner := bufio.NewScanner(strings.NewReader(script.Output))
				for scanner.Scan() {
					fields := strings.Fields(scanner.Text())
					if len(fields) == 0 {
						continue
					}
					if strings.Contains(fields[0], "CVE") {
						if !slices.Contains(cves, fields[0]) {
							cves = append(cves, fields[0])
						}
						hash := Hash(fields[0]) * uint64(port.PortId)
						vuln := PentestVulns{
							Id:   fields[0],
							CVSS: fields[1],
							Port: port.PortId,
							CPE:  script.Tables[0].Key,
						}
						vulnsList[fmt.Sprintf("%0.16x", hash)] = vuln
					}
				}
			}
		}
	}
	var cveDB []models.Vulnerability = make([]models.Vulnerability, 0)
	// Request all found cve's in Database
	if err := database.PostgreDB.Where("name IN ?", cves).Preload("CVSS").Preload("CWE").Preload("Description", "language = ?", lang).Preload("Solutions", "language = ?", lang).Find(&cveDB).Error; err != nil {
		log.Printf("Error finding cve's: %v", err)
	}
	// Map them for quicker access
	var cveMap map[string]models.Vulnerability = map[string]models.Vulnerability{}
	for _, c := range cveDB {
		cveMap[c.Name] = c
	}
	for k, v := range vulnsList {
		cve := cveMap[v.Id]
		var cwe []string = make([]string, 0)
		for _, c := range cve.CWE {
			cwe = append(cwe, c.CWE)
		}

		v.CVSSVector = cve.CVSS.Vector
		v.References = cve.Link
		v.CWE = cwe
		if len(cve.Description) != 0 {
			v.Description = cve.Description[0].Text
		}
		if len(cve.Solutions) != 0 {
			v.Solutions = cve.Solutions[0].Text
		}
		vulnsList[k] = v
	}
	log.Printf("Nmap output : %d", len(vulnsList))
	return vulnsList
}

func extractHostScripts(scripts []Script) []map[string]interface{} {
	var scriptList []map[string]interface{}
	for _, script := range scripts {
		scriptList = append(scriptList, map[string]interface{}{
			"id":     script.Id,
			"output": interpretScriptOutput(script.Output),
		})
	}
	return scriptList
}

// extractPortsInfo extracts port information.
func extractPortsInfo(ports []Port) []PentestPort {
	var portList []PentestPort = make([]PentestPort, 0)
	for _, port := range ports {
		portList = append(portList, PentestPort{
			Port:     port.PortId,
			Protocol: port.Protocol,
			State:    port.State.State,
			Service:  port.Service.Name,
			//"scripts":  extractHostScripts(port.Scripts),
		})
	}
	return portList
}

// getAddress gets IP address from addresses.
func getAddress(addresses []Address) string {
	for _, addr := range addresses {
		if addr.AddrType == "ipv4" || addr.AddrType == "ipv6" {
			return addr.Addr
		}
	}
	return "unknown"
}

func interpretScriptOutput(output string) string {
	output = strings.ToLower(output)

	switch {
	case strings.Contains(output, "vulnerable"):
		return "Уязвимость обнаружена"
	case strings.Contains(output, "exploitable"):
		return "Уязвимость может быть использована"
	case strings.Contains(output, "vulnerability detected"):
		return "Уязвимость подтверждена"
	case strings.Contains(output, "not vulnerable"):
		return "Уязвимость отсутствует"
	case strings.Contains(output, "false"):
		return "Уязвимость не найдена"
	case strings.Contains(output, "no issues found"):
		return "Проблем не обнаружено"
	case strings.Contains(output, "secure"):
		return "Конфигурация безопасна"
	case strings.Contains(output, "access denied"):
		return "Доступ запрещен"
	case strings.Contains(output, "nt_status_access_denied"):
		return "Ошибка доступа (Windows)"
	case strings.Contains(output, "permission denied"):
		return "Отказано в разрешении"
	case strings.Contains(output, "authentication required"):
		return "Требуется аутентификация"
	/*case strings.Contains(output, "error"):
	return "Общая ошибка"*/
	case strings.Contains(output, "failed"):
		return "Тест не выполнен"
	case strings.Contains(output, "could not connect"):
		return "Не удалось подключиться"
	case strings.Contains(output, "timeout"):
		return "Превышено время ожидания"
	case strings.Contains(output, "connection refused"):
		return "Соединение отклонено"
	case strings.Contains(output, "host unreachable"):
		return "Хост недоступен"
	case strings.Contains(output, "info"):
		return "Общая информация"
	case strings.Contains(output, "discovered"):
		return "Выявлены определенные параметры"
	case strings.Contains(output, "found"):
		return "Обнаружено"
	case strings.Contains(output, "detected"):
		return "Зафиксировано"
	case strings.Contains(output, "potentially vulnerable"):
		return "Возможно уязвим"
	case strings.Contains(output, "requires manual verification"):
		return "Требуется ручная проверка"
	case strings.Contains(output, "open to attacks"):
		return "Открыт для атак"
	case strings.Contains(output, "vulnerable but requires authentication"):
		return "Уязвимость есть, но требуется аутентификация"
	case strings.Contains(output, "incomplete test"):
		return "Тест не завершен, результат может быть неточным"
	default:
		return "Результат: " + output
	}
}
