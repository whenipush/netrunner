package handlers

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
)

// ProcessNmapFile reads XML, parses and saves as JSON.
func ProcessPentest(inputFile string, outputFile string) (string, error) {
	data, err := os.ReadFile(inputFile)
	if err != nil {
		return "", err
	}

	nmapData, err := Parse(data)
	if err != nil {
		return "", err
	}

	jsonData := generateJSON(nmapData)

	err = saveJSONToFile(outputFile, jsonData)
	if err != nil {
		return "", err
	}

	return outputFile, err
}

// saveJSONToFile saves JSON to a file.
func saveJSONToFile(filename string, data interface{}) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// generateJSON generates JSON structure.
func generateJSON(nmapData *NmapRun) map[string]interface{} {
	return map[string]interface{}{
		"general_info": map[string]interface{}{
			"start":   nmapData.StartStr,
			"end":     nmapData.RunStats.Finished.TimeStr,
			"version": nmapData.Version,
			"elapsed": fmt.Sprintf("%.2f", nmapData.RunStats.Finished.Elapsed),
			"summary": nmapData.RunStats.Finished.Summary,
			"up":      nmapData.RunStats.Hosts.Up,
			"down":    nmapData.RunStats.Hosts.Down,
			"total":   nmapData.RunStats.Hosts.Total,
		},
		"hosts": extractHostsInfo(nmapData.Hosts),
	}
}

// extractHostsInfo extracts host information.
func extractHostsInfo(hosts []Host) []map[string]interface{} {
	var hostList []map[string]interface{}
	for _, host := range hosts {
		hostInfo := map[string]interface{}{
			"ip":           getAddress(host.Addresses),
			"status":       host.Status.State,
			"ports":        extractPortsInfo(host.Ports),
			"scripts":      extractHostScripts(host.HostScripts), // Adding scripts for ports
			"host_scripts": extractHostScripts(host.HostScripts), // Adding host scripts
		}
		hostList = append(hostList, hostInfo)
	}
	return hostList
}

func extractHostScripts(scripts []Script) []map[string]interface{} {
	var scriptList []map[string]interface{}
	for _, script := range scripts {
		scriptList = append(scriptList, map[string]interface{}{
			"id":     script.Id,
			"output": interpretScriptOutput(script.Output),
		})
	}
	return scriptList
}

// extractPortsInfo extracts port information.
func extractPortsInfo(ports []Port) []map[string]interface{} {
	var portList []map[string]interface{}
	for _, port := range ports {
		portList = append(portList, map[string]interface{}{
			"port":     port.PortId,
			"protocol": port.Protocol,
			"state":    port.State.State,
			"service":  port.Service.Name,
			"scripts":  extractHostScripts(port.Scripts),
		})
	}
	return portList
}

// getAddress gets IP address from addresses.
func getAddress(addresses []Address) string {
	for _, addr := range addresses {
		if addr.AddrType == "ipv4" || addr.AddrType == "ipv6" {
			return addr.Addr
		}
	}
	return "unknown"
}

func interpretScriptOutput(output string) string {
	output = strings.ToLower(output)

	switch {
	case strings.Contains(output, "vulnerable"):
		return "Уязвимость обнаружена"
	case strings.Contains(output, "exploitable"):
		return "Уязвимость может быть использована"
	case strings.Contains(output, "vulnerability detected"):
		return "Уязвимость подтверждена"
	case strings.Contains(output, "not vulnerable"):
		return "Уязвимость отсутствует"
	case strings.Contains(output, "false"):
		return "Уязвимость не найдена"
	case strings.Contains(output, "no issues found"):
		return "Проблем не обнаружено"
	case strings.Contains(output, "secure"):
		return "Конфигурация безопасна"
	case strings.Contains(output, "access denied"):
		return "Доступ запрещен"
	case strings.Contains(output, "nt_status_access_denied"):
		return "Ошибка доступа (Windows)"
	case strings.Contains(output, "permission denied"):
		return "Отказано в разрешении"
	case strings.Contains(output, "authentication required"):
		return "Требуется аутентификация"
	/*case strings.Contains(output, "error"):
	return "Общая ошибка"*/
	case strings.Contains(output, "failed"):
		return "Тест не выполнен"
	case strings.Contains(output, "could not connect"):
		return "Не удалось подключиться"
	case strings.Contains(output, "timeout"):
		return "Превышено время ожидания"
	case strings.Contains(output, "connection refused"):
		return "Соединение отклонено"
	case strings.Contains(output, "host unreachable"):
		return "Хост недоступен"
	case strings.Contains(output, "info"):
		return "Общая информация"
	case strings.Contains(output, "discovered"):
		return "Выявлены определенные параметры"
	case strings.Contains(output, "found"):
		return "Обнаружено"
	case strings.Contains(output, "detected"):
		return "Зафиксировано"
	case strings.Contains(output, "potentially vulnerable"):
		return "Возможно уязвим"
	case strings.Contains(output, "requires manual verification"):
		return "Требуется ручная проверка"
	case strings.Contains(output, "open to attacks"):
		return "Открыт для атак"
	case strings.Contains(output, "vulnerable but requires authentication"):
		return "Уязвимость есть, но требуется аутентификация"
	case strings.Contains(output, "incomplete test"):
		return "Тест не завершен, результат может быть неточным"
	default:
		return "Результат: " + output
	}
}
